<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>小付的新♂日♂暮♂里</title>
    <link>https://dickfql.github.io/</link>
    
    <atom:link href="https://dickfql.github.io/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>振兴哲♂学，Ass ♂ We ♂ Can!.</description>
    <pubDate>Wed, 16 Feb 2022 14:56:10 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>学习XXE</title>
      <link>https://dickfql.github.io/2022/01/07/%E5%AD%A6%E4%B9%A0XXE/</link>
      <guid>https://dickfql.github.io/2022/01/07/%E5%AD%A6%E4%B9%A0XXE/</guid>
      <pubDate>Fri, 07 Jan 2022 08:57:18 GMT</pubDate>
      
      <description>&lt;p&gt;最近两天在学习XXE攻击，顺便就把xml学习了一下，正好做一下笔记。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>最近两天在学习XXE攻击，顺便就把xml学习了一下，正好做一下笔记。</p><span id="more"></span><p>​        XXE：XML External Entity 即外部实体，从安全角度理解成XML External Entity attack 外部实体注入攻击。由于程序在解析输入的XML数据时，解析了攻击者伪造的外部实体而产生的。例如PHP中的’’simplexml_load’’默认情况下会解析外部实体，有XXE漏洞的标志性函数为simplexml_load_string（）。</p><p>​        要搞懂XXE，就得先学习一下xml。xml我在<a href="https://www.w3school.com.cn/xml/index.asp">W3C</a>上简要的理解了下。</p><h1 id="什么是XML？"><a href="#什么是XML？" class="headerlink" title="什么是XML？"></a>什么是XML？</h1><ul><li>XML 指可扩展标记语言（<em>EX</em>tensible <em>M</em>arkup <em>L</em>anguage）</li><li>XML 是一种<em>标记语言</em>，很类似 HTML</li><li>XML 的设计宗旨是<em>传输数据</em>，而非显示数据</li><li>XML 标签没有被预定义。您需要<em>自行定义标签</em>。</li><li>XML 被设计为具有<em>自我描述性</em>。</li></ul><h1 id="XML有什么用？"><a href="#XML有什么用？" class="headerlink" title="XML有什么用？"></a>XML有什么用？</h1><p><strong>XML 应用于 web 开发的许多方面，常用于简化数据的存储和共享。</strong></p><h2 id="XML-把数据从-HTML-分离"><a href="#XML-把数据从-HTML-分离" class="headerlink" title="XML 把数据从 HTML 分离"></a>XML 把数据从 HTML 分离</h2><p>如果你需要在 HTML 文档中显示动态数据，那么每当数据改变时将花费大量的时间来编辑 HTML。</p><p>通过 XML，数据能够存储在独立的 XML 文件中。这样你就可以专注于使用 HTML 进行布局和显示，并确保修改底层数据不再需要对 HTML 进行任何的改变。</p><p>通过使用几行 JavaScript，你就可以读取一个外部 XML 文件，然后更新 HTML 中的数据内容。</p><h1 id="XML-与-HTML-的主要差异"><a href="#XML-与-HTML-的主要差异" class="headerlink" title="XML 与 HTML 的主要差异"></a>XML 与 HTML 的主要差异</h1><ul><li>XML 不是 HTML 的替代。</li><li>XML 和 HTML 为不同的目的而设计：</li><li>XML 被设计为传输和存储数据，其焦点是数据的内容。</li><li>HTML 被设计用来显示数据，其焦点是数据的外观。</li><li>HTML 旨在显示信息，而 XML 旨在传输信息。</li></ul><p>XML格式</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;??&gt;</span> </span><br><span class="line">//第一行是 XML 声明。           </span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">note</span> [//定义此文档是 note 类型的文档。</span></span><br><span class="line"><span class="meta">  <span class="meta">&lt;!ELEMENT <span class="meta-keyword">note</span> (<span class="meta-keyword">to</span>,<span class="meta-keyword">from</span>,<span class="meta-keyword">heading</span>,<span class="meta-keyword">body</span>)&gt;</span>//定义 note 元素有四个元素：&quot;to、from、heading,、body&quot;</span></span><br><span class="line"><span class="meta">  <span class="meta">&lt;!ELEMENT <span class="meta-keyword">to</span>      (<span class="meta-keyword">#PCDATA</span>)&gt;</span></span></span><br><span class="line"><span class="meta">  <span class="meta">&lt;!ELEMENT <span class="meta-keyword">from</span>    (<span class="meta-keyword">#PCDATA</span>)&gt;</span></span></span><br><span class="line"><span class="meta">  <span class="meta">&lt;!ELEMENT <span class="meta-keyword">heading</span> (<span class="meta-keyword">#PCDATA</span>)&gt;</span></span></span><br><span class="line"><span class="meta">  <span class="meta">&lt;!ELEMENT <span class="meta-keyword">body</span>    (<span class="meta-keyword">#PCDATA</span>)&gt;</span></span></span><br><span class="line"><span class="meta">]&gt;</span> //DTD部分</span><br><span class="line">//————————————————————————————————————————————————————————————————————————————————   </span><br><span class="line"><span class="tag">&lt;<span class="name">note</span>&gt;</span>//使用定义的标签</span><br><span class="line">  <span class="tag">&lt;<span class="name">to</span>&gt;</span>George<span class="tag">&lt;/<span class="name">to</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">from</span>&gt;</span>John<span class="tag">&lt;/<span class="name">from</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">heading</span>&gt;</span>Reminder<span class="tag">&lt;/<span class="name">heading</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span>Don&#x27;t forget the meeting!<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">note</span>&gt;</span>//XML使用部分</span><br><span class="line">//————————————————————————————————————————————————————————————————————————————————</span><br></pre></td></tr></table></figure><p>XML声明：很简单，<?xml version="1.0" encoding="utf-8"??> ，它定义 XML 的版本 (1.0) 和所使用的编码 (ISO-8859-1 = Latin-1/西欧字符集)。</p><p>DTD部分：这部分可以理解为定义标签，然后再XML部分使用定义的标签。  </p><p>XML部分：调用定义的标签</p><h1 id="DOCTYPE-声明"><a href="#DOCTYPE-声明" class="headerlink" title="DOCTYPE 声明"></a>DOCTYPE 声明</h1><h2 id="内部-DOCTYPE-声明"><a href="#内部-DOCTYPE-声明" class="headerlink" title="内部 DOCTYPE 声明"></a>内部 DOCTYPE 声明</h2><p>假如 DTD 被包含在您的 XML 源文件中，它应当通过下面的语法包装在一个 DOCTYPE 声明中：</p><p><code>&lt;!DOCTYPE 根元素 [元素声明]&gt;</code></p><h2 id="外部DOCTYPE-文档声明"><a href="#外部DOCTYPE-文档声明" class="headerlink" title="外部DOCTYPE 文档声明"></a>外部DOCTYPE 文档声明</h2><p>假如 DTD 位于 XML 源文件的外部，那么它应通过下面的语法被封装在一个 DOCTYPE 定义中：</p><p><code>&lt;!DOCTYPE 根元素 SYSTEM &quot;文件名&quot;&gt;</code></p><p><strong>助于理解：这就好比是个标记，告诉计算机从这里开始（!DOCTYPE）是定义的部分，定义的东西如下。计算机看到（!DOCTYPE）后就知道这里是定义的东西，下面XML部分的内容要用到。定义起始用DOCTYPE，定义元素用ELEMENT，定义实体用ENTITY。</strong></p><h1 id="元素声明"><a href="#元素声明" class="headerlink" title="元素声明"></a>元素声明</h1><p>普通元素</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ELEMENT 元素名称 类别&gt;或者&lt;!ELEMENT 元素名称 (元素内容)&gt;</span><br></pre></td></tr></table></figure><p>空元素</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ELEMENT 元素名称 EMPTY&gt;或者&lt;!ELEMENT br EMPTY&gt;</span><br></pre></td></tr></table></figure><p>其余元素不介绍了，可以自行了解。</p><h1 id="实体声明"><a href="#实体声明" class="headerlink" title="实体声明"></a>实体声明</h1><p>内部实体</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ENT0TY 实体名称 &quot;实体的值&quot;&gt;</span><br><span class="line">例如：</span><br><span class="line">&lt;!ENTITY writer &quot;Bill Gates&quot;&gt;</span><br></pre></td></tr></table></figure><p>外部实体</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ENTITY 实体名称 SYSTEM &quot;URI/URL&quot;&gt;</span><br><span class="line">例如：</span><br><span class="line">&lt;!ENTITY writer SYSTEM &quot;http://www.w3school.com.cn/dtd/entities.dtd&quot;&gt;</span><br><span class="line">&lt;!ENTITY xxe SYSTEM &quot;file:///etc/passwd&quot;&gt;</span><br><span class="line">//漏洞关键,定义外部实体别忘加SYSTEM</span><br></pre></td></tr></table></figure><p><strong>注释:</strong> 一个实体由三部分构成: 一个和号 (&amp;), 一个实体名称, 以及一个分号 (;)。如：&writer;、&xxe;</p><h1 id="延申"><a href="#延申" class="headerlink" title="延申"></a>延申</h1><h2 id="PCDATA"><a href="#PCDATA" class="headerlink" title="PCDATA"></a>PCDATA</h2><p>PCDATA 的意思是被解析的字符数据（parsed character data）。</p><p>可把字符数据想象为 XML 元素的开始标签与结束标签之间的文本。</p><p><strong>PCDATA 是会被解析器解析的文本。这些文本将被解析器检查实体以及标记。</strong></p><p>助于理解：意思是使用’&lt;’符号的时候，需要写成实体形：&amp; l t ; （去掉中间的空格）</p><h2 id="CDATA"><a href="#CDATA" class="headerlink" title="CDATA"></a>CDATA</h2><p>CDATA 的意思是字符数据（character data）。</p><p><strong>CDATA 是不会被解析器解析的文本。</strong>在这些文本中的标签不会被当作标记来对待，其中的实体也不会被展开。</p><p><em><strong>总结：综上学完可以基本了解了XML的东西，也能理解XXE。</strong></em></p><h1 id="XXE"><a href="#XXE" class="headerlink" title="XXE"></a>XXE</h1><p>在外部实体中加入恶意代码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE note [ &lt;!ENTITY xxe &quot;test&quot;&gt; ] &gt;</span><br><span class="line">&lt;name&gt;&amp;xxe;&lt;/name&gt;</span><br></pre></td></tr></table></figure><p>回显：test（普通的调用外部实体）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version = &quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE ANY [ &lt;!ENTITY xxe SYSTEM &quot;php://filter/read=convert.base64-encode/resource=xxe.php&quot;&gt; ] &gt;</span><br><span class="line">&lt;x&gt;&amp;xxe;&lt;/x&gt;</span><br></pre></td></tr></table></figure><p>回显：文件xxe.php的base64的值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version = &quot;1.0&quot;?&gt; </span><br><span class="line">&lt;!DOCTYPE ANY [ &lt;!ENTITY xxe SYSTEM &quot;file:///etc/passwd&quot;&gt; ] &gt;</span><br><span class="line">&lt;x&gt;&amp;xxe;&lt;/x&gt;</span><br></pre></td></tr></table></figure><p>回显：Linux系统下的/etc/passwd文件信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE foo [&lt;!ELEMENT foo ANY &gt;</span><br><span class="line">&lt;!ENTITY  xxe SYSTEM &quot;file:///c:/windows/win.ini&quot; &gt;]&gt;</span><br><span class="line">&lt;foo&gt;&amp;xxe;&lt;/foo&gt;</span><br></pre></td></tr></table></figure><p>回显：Win系统下的c:/windows/win.ini文件信息</p><h1 id="为什么攻击会成功？"><a href="#为什么攻击会成功？" class="headerlink" title="为什么攻击会成功？"></a>为什么攻击会成功？</h1><p>1、php打开了外部实体解析</p><p>代码中$data = @simplexml_load_string($xml,’SimpleXMLElement’,LIBXML_NOENT);</p><p>而LIBXML_NOENT参数开启了外部实体解析，libxml2.9.1及以后，默认不解析外部实体。当XML声明中stand_alone值是yes的时候表示DTD仅用于验证文档结构，外部实体将被禁用。但它的默认值是no，而且有些parser会直接忽略这一项。</p><p>2、外部实体含有恶意代码</p><p>本来外部实体用于引用外部的.dtd文件，用文件里面定义好的标签。但是外部实体使用了恶意代码如:”file:///etc/passwd”、”php://filter/read=convert.base64-encode/resource=xxe.php”,导致文件被任意读取。</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content:encoded>
      
      
      
      <category domain="https://dickfql.github.io/tags/xxe/">xxe</category>
      
      
      <comments>https://dickfql.github.io/2022/01/07/%E5%AD%A6%E4%B9%A0XXE/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>信息收集</title>
      <link>https://dickfql.github.io/2022/01/06/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/</link>
      <guid>https://dickfql.github.io/2022/01/06/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/</guid>
      <pubDate>Thu, 06 Jan 2022 08:53:27 GMT</pubDate>
      
      <description>&lt;p&gt;whois查询，备案信息，敏感信息，子域名信息，指纹识别，真实ip……&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>whois查询，备案信息，敏感信息，子域名信息，指纹识别，真实ip……</p><span id="more"></span><p>whois查询<br>站长之家可查whois，dns，过期域名，备案，域名删除<br><a href="https://whois.chinaz.com/">https://whois.chinaz.com/</a> 域名whois查询，域名服务商，拥有者<br><a href="https://whois.aizhan.com/">https://whois.aizhan.com/</a> 域名whois查询，及相关信息</p><p>备案信息<br><a href="https://icp.chinaz.com/">https://icp.chinaz.com/</a> 网站备案</p><p>敏感信息<br>Google hack （site:edu.cn intext:后台管理）<br>Google hack一些用法：<a href="https://jishuin.proginn.com/p/763bfbd29e15">https://jishuin.proginn.com/p/763bfbd29e15</a><br>github寻找敏感信息，乌云漏洞表</p><p>子域名信息<br>Layer子域名挖掘机，subDomainBrute，Sublist3r   三种应用<br>kali中有: Sublist3r<br>谷歌语法：site:xxx.com<br>在线子域名查询：<a href="https://phpinfo.me/domain/">https://phpinfo.me/domain/</a><br>ip反查绑定域名：<a href="http://dns.aizhan.com/">http://dns.aizhan.com</a><br>域名解析记录：<a href="https://dnsdumpster.com/">https://dnsdumpster.com/</a><br>多地ping：<a href="http://ping.chinaz.com/">http://ping.chinaz.com/</a><br>同ip网站查询：<a href="https://www.webscan.cc/">https://www.webscan.cc/</a><br>通过证书查域名或子域名：<a href="https://crt.sh/">https://crt.sh/</a>            </p><p>指纹识别<br><a href="http://whatweb.bugscaner.com/look/">http://whatweb.bugscaner.com/look/</a>    cms指纹识别(是否为cms)<br><a href="https://www.yunsee.cn/">https://www.yunsee.cn/</a>        云悉指纹<br><a href="https://www.whatweb.net/">https://www.whatweb.net/</a>            </p><p>真实IP<br><a href="https://www.netcraft.com/">https://www.netcraft.com/</a>        查看域名解析记录（看不懂）<br>IP精准定位：<a href="https://www.ipuu.net/#/home">https://www.ipuu.net/#/home</a><br>IP 138：<a href="https://site.ip138.com/">https://site.ip138.com/</a><br>Security Trails：<a href="https://securitytrails.com/">https://securitytrails.com/</a><br>app抓包</p><p><a href="https://mail.protonmail.com/inbox?welcome=true">https://mail.protonmail.com/inbox?welcome=true</a> proton邮箱<br><a href="https://rootsh.com/">https://rootsh.com/</a> 10分钟邮箱<br><a href="https://yunduanxin.net/info/8618411632871/">https://yunduanxin.net/info/8618411632871/</a> 云短信（各地区短信接收<br><a href="https://www.virustotal.com/gui/">https://www.virustotal.com/gui/</a> 软件扫描<br><a href="http://www.alexa.cn/">http://www.alexa.cn/</a> 网站流量</p><p><a href="https://xz.aliyun.com/t/2536#toc-13">https://xz.aliyun.com/t/2536#toc-13</a> 后渗透</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content:encoded>
      
      
      <category domain="https://dickfql.github.io/categories/web/">web</category>
      
      <category domain="https://dickfql.github.io/categories/web/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/">信息收集</category>
      
      
      
      <comments>https://dickfql.github.io/2022/01/06/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>CSRF漏洞</title>
      <link>https://dickfql.github.io/2021/11/17/csrf/</link>
      <guid>https://dickfql.github.io/2021/11/17/csrf/</guid>
      <pubDate>Wed, 17 Nov 2021 03:59:42 GMT</pubDate>
      
      <description>&lt;p&gt;这个漏洞刷题的时候不常遇到，但是面试的时候几乎回回提到，今天就尝试把这漏洞搞懂一下。&lt;/p&gt;
&lt;p&gt;什么是csrf漏洞？危害大吗？如何利用漏洞？如何防御漏洞？与xss漏洞、ssrf漏洞的区别？&lt;/p&gt;
&lt;p&gt;今天就着重把这个漏洞和延申问题解决一下。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>这个漏洞刷题的时候不常遇到，但是面试的时候几乎回回提到，今天就尝试把这漏洞搞懂一下。</p><p>什么是csrf漏洞？危害大吗？如何利用漏洞？如何防御漏洞？与xss漏洞、ssrf漏洞的区别？</p><p>今天就着重把这个漏洞和延申问题解决一下。</p><span id="more"></span><h1 id="一、什么是CSRF漏洞？"><a href="#一、什么是CSRF漏洞？" class="headerlink" title="一、什么是CSRF漏洞？"></a>一、什么是CSRF漏洞？</h1><p>​        跨站请求伪造（Cross Site Request Forgery）漏洞是早年前的一种网络攻击方式，曾被称为“One Click Attack”或者Session Riding（可不是点击劫持和会话劫持），缩写为CSRF。正如漏洞其名：伪造跨站请求，简单的来说就是攻击者窃取用户信息，并且利用其的信息进入带有csrf漏洞的网站，做出恶意操作的攻击方式。</p><h1 id="二、危害大吗？"><a href="#二、危害大吗？" class="headerlink" title="二、危害大吗？"></a>二、危害大吗？</h1><p>​        它在 2007 年曾被列为互联网 20 大安全隐患之一，黑客可以盗用了你的身份，以你的名义发送恶意请求。此外能够做的事情包括：以你名义发送邮件，发消息，盗取你的账号，甚至于购买商品，虚拟货币转账……</p><p>造成的问题就是个人隐私泄露以及财产安全。总的来说csrf漏洞的危害性还是蛮大的，并且还难以防范。</p><h1 id="三、如何利用漏洞？"><a href="#三、如何利用漏洞？" class="headerlink" title="三、如何利用漏洞？"></a>三、如何利用漏洞？</h1><p>这里以DVWA平台CSRF模块为例，利用漏洞可以造成无需密码就可以修改用户密码。</p><p>等级：low</p><p>这个等级下，后端只有判断密码是否相同的限制，而没有别的限制要求，所以只需要构造一个改密码的链接即可。</p><p>构造一个图片，让用户点击并访问：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;2.html&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;http://127.0.0.1/dvwa/vulnerabilities/csrf/?password_new=ab&amp;password_conf=ab&amp;Change=Change#&quot;</span>&gt;</span>点击重试<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>等级：medium</p><p>这个等级下，后端判断了密码是否相同，还添加了限制Referer的条件（来源域名与访问域名一致）。所以修改请求的来源就可以绕过。</p><p>等级：high</p><p>这个等级下，后端判断了密码是否相同，还添加了判断token的条件。这个情况下就麻烦了，先要获得存在csrf漏洞的网站的token值（在xss（stored）模块），把获得的token值添加到攻击代码中，然后通过medium等级下一样的方式绕过即可。</p><p>（之后更新具体攻击流程还有完成pikachu平台的csrf模块）</p><h1 id="四、如何防御漏洞？"><a href="#四、如何防御漏洞？" class="headerlink" title="四、如何防御漏洞？"></a>四、如何防御漏洞？</h1><p>​        在业界目前防御 CSRF 攻击主要有三种策略：1、验证 HTTP Referer 字段；2、在请求地址中添加 token 并验证；3、在 HTTP 头中自定义属性并验证。下面就分别对这三种策略进行详细介绍。</p><h2 id="4-1、验证-HTTP-Referer-字段"><a href="#4-1、验证-HTTP-Referer-字段" class="headerlink" title="4.1、验证 HTTP Referer 字段"></a>4.1、验证 HTTP Referer 字段</h2><p>​        根据 HTTP 协议，在 HTTP 头中有一个字段叫 Referer，它记录了该 HTTP 请求的来源地址。在通常情况下，访问一个安全受限页面的请求来自于同一个网站，比如需要访问 <code>http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=Mallory</code>，用户必须先登陆 bank.example，然后通过点击页面上的按钮来触发转账事件。因此，要防御 CSRF 攻击，网站只需要对于每一个转账请求验证其 Referer 值，如果是以 bank.example 开头的域名，则说明该请求是来自银行网站自己的请求，是合法的。如果 Referer 是其他网站的话，则有可能是黑客的 CSRF 攻击，拒绝该请求。</p><h2 id="4-2、在请求地址中添加-token-并验证"><a href="#4-2、在请求地址中添加-token-并验证" class="headerlink" title="4.2、在请求地址中添加 token 并验证"></a>4.2、在请求地址中添加 token 并验证</h2><p>​        CSRF 攻击之所以能够成功，是因为黑客可以完全伪造用户的请求，该请求中所有的用户验证信息都是存在于 cookie 中，因此黑客可以在不知道这些验证信息的情况下直接利用用户自己的 cookie 来通过安全验证。要抵御 CSRF，关键在于在请求中放入黑客所不能伪造的信息，并且该信息不存在于 cookie 之中。可以在 HTTP 请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证这个 token，如果请求中没有 token 或者 token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求。</p><h2 id="4-3、在-HTTP-头中自定义属性并验证"><a href="#4-3、在-HTTP-头中自定义属性并验证" class="headerlink" title="4.3、在 HTTP 头中自定义属性并验证"></a>4.3、在 HTTP 头中自定义属性并验证</h2><p>​        这种方法也是使用 token 并进行验证，和上一种方法不同的是，这里并不是把 token 以参数的形式置于 HTTP 请求之中，而是把它放到 HTTP 头中自定义的属性里。通过 XMLHttpRequest 这个类，可以一次性给所有该类请求加上 csrftoken 这个 HTTP 头属性，并把 token 值放入其中。这样解决了上种方法在请求中加入 token 的不便，同时，通过 XMLHttpRequest 请求的地址不会被记录到浏览器的地址栏，也不用担心 token 会透过 Referer 泄露到其他网站中去。</p><h1 id="五、与XSS漏洞，SSRF漏洞的区别？"><a href="#五、与XSS漏洞，SSRF漏洞的区别？" class="headerlink" title="五、与XSS漏洞，SSRF漏洞的区别？"></a>五、与XSS漏洞，SSRF漏洞的区别？</h1><p>​        XSS利用站点内的信任用户，而CSRF则通过<code>伪装来自受信任用户</code>的请求来利用受信任的网站。与<a href="https://link.jianshu.com/?t=http://baike.baidu.com/view/50325.htm">XSS</a>攻击相比，CSRF攻击往往不大流行（因此对其进行防范的资源也相当稀少）和<code>难以防范</code>，所以被认为比<a href="https://link.jianshu.com/?t=http://baike.baidu.com/view/50325.htm">XSS</a><code>更具危险性</code>。</p><p>​        SSRF(Server Side Request Forgery)：服务器端请求伪造。从字面上来看，与CSRF不同的是，它是服务器端发出的请求伪造而非从用户一端提交。别误会，作为受信任用户，服务器当然不可能做出损害用户信息的事。它是一种由攻击者构造形成，由服务端发起请求的一个安全漏洞。因为它是由服务端发起的，所以它能够请求到与它相连但与外网隔离的内部系统。由于服务端提供了从其他服务器应用获取数据的功能（例如分享等功能）且没有对目标地址做过滤与限制，给予了攻击者乘虚而入的机会。比如从指定URL地址获取网页文本内容，加载指定地址的图片，下载等等。SSRF是利用存在缺陷的web应用作为代理攻击远程和本地的服务器。</p><h1 id="六、延申"><a href="#六、延申" class="headerlink" title="六、延申"></a>六、延申</h1><h2 id="6-1、-cookie、session、token的区别"><a href="#6-1、-cookie、session、token的区别" class="headerlink" title="6.1、 cookie、session、token的区别"></a>6.1、 cookie、session、token的区别</h2><p><strong>cookie与session区别</strong> </p><p>cookie数据存放在客户端上，session数据放在服务器上；</p><p>cookie不是很安全，且保存数据有限； session一定时间内保存在服务器上,当访问增多，占用服务器性能。</p><p><strong>session与token</strong> </p><p>作为身份认证，token安全行比session好； Session 认证只是简单的把User 信息存储到Session 里，因为SID 的不可预测性，暂且认为是安全的。这是一种认证手段。 而Token ，如果指的是OAuth Token 或类似的机制的话，提供的是<code>认证</code> 和 <code>授权</code> ，认证是针对用户，授权是针对App 。其目的是让 某App有权利访问 某用户 的信息。</p><p><strong>token与cookie</strong> </p><p>Cookie是不允许垮域访问的，但是token是支持的， 前提是传输的用户认证信息通过HTTP头传输；</p><p>token就是令牌，比如你授权（登录）一个程序时，他就是个依据，判断你是否已经授权该软件；cookie就是写在客户端的一个txt文件，里面包括你登录信息之类的，这样你下次在登录某个网站，就会自动调用cookie自动登录用户名；session和cookie差不多，只是session是写在服务器端的文件，也需要在客户端写入cookie文件，但是文件里是你的浏览器编号.Session的状态是存储在服务器端，客户端只有session id；而Token的状态是存储在客户端。</p><h1 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h1><p>文章主要参考了别的师傅的文章的，差不多自己解决了这个问题，如果没懂的话可以参考这位师傅的<a href="https://www.jianshu.com/p/7f33f9c7997b">文章</a>，他写得比我详细些。</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content:encoded>
      
      
      <category domain="https://dickfql.github.io/categories/web/">web</category>
      
      <category domain="https://dickfql.github.io/categories/web/php/">php</category>
      
      
      <category domain="https://dickfql.github.io/tags/csrf/">csrf</category>
      
      
      <comments>https://dickfql.github.io/2021/11/17/csrf/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>PHP之MD5变式</title>
      <link>https://dickfql.github.io/2021/10/23/md5/</link>
      <guid>https://dickfql.github.io/2021/10/23/md5/</guid>
      <pubDate>Sat, 23 Oct 2021 02:30:06 GMT</pubDate>
      
      <description>&lt;p&gt;MD5经典等式，弱类型比较大杂烩。&lt;br&gt;目前有$a==md5($a)、$a!=$b，md5(a)==md5(b)、$a!=$b，md5(a)==md5(b)、MD5截断、md5($password,true)。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>MD5经典等式，弱类型比较大杂烩。<br>目前有$a==md5($a)、$a!=$b，md5(a)==md5(b)、$a!=$b，md5(a)==md5(b)、MD5截断、md5($password,true)。</p><span id="more"></span><h2 id="a-md5-a"><a href="#a-md5-a" class="headerlink" title="$a==md5($a)"></a>$a==md5($a)</h2><p>a=0e215962017 的 MD5 值也是由 0e 开头，在 PHP 弱类型比较中相等</p><h2 id="a-b，md5-a-md5-b"><a href="#a-b，md5-a-md5-b" class="headerlink" title="$a!=$b，md5(a)==md5(b)"></a>$a!=$b，md5(a)==md5(b)</h2><p>两个不同的字符串，MD5加密后相等。<br>PHP会把每一个以”0E”开头的哈希值都解释为0，所以选择加密后为0E开头的字符串就行。<br>QNKCDZO，s155964671a，s214587387a,s878926199a,这些字符串的哈希值都是为’0E’开头。</p><h2 id="a-b，md5-a-md5-b-1"><a href="#a-b，md5-a-md5-b-1" class="headerlink" title="$a!==$b，md5(a)===md5(b)"></a>$a!==$b，md5(a)===md5(b)</h2><p>绝对相等和绝对不等，这种情况要求就高了。<br>“===”：等式两边，类型一致，值一致，否则就为假。”!==”：等式两边，类型或值不一致就为真，否则就为假。<br>绕过方式1：<br>md5()不能处理数组，传数组就为null，所以传数组，a[]=1,b[]=2就能绕过了<br>注：md5()函数，pre_match()函数,strcmp()函数都无法处理数组</p><h2 id="MD5截断"><a href="#MD5截断" class="headerlink" title="MD5截断"></a>MD5截断</h2><p>substr(md5($a),5,5)=”xxxxx”<br>输入明文，MD5加密后的值截取一部分字符串的值等于指定字符串的值。<br>针对每个数字进行MD5加密，截取部分字符串进行比对。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import hashlib</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(1,1000001):</span><br><span class="line">    m = hashlib.md5()</span><br><span class="line">    m.update(str(i).encode())</span><br><span class="line">    <span class="keyword">if</span> m.hexdigest()[5:10] == <span class="string">&quot;aceaa&quot;</span>:</span><br><span class="line">        <span class="built_in">print</span>(i)</span><br><span class="line">        <span class="built_in">break</span></span><br></pre></td></tr></table></figure><h2 id="md5-password-true"><a href="#md5-password-true" class="headerlink" title="md5($password,true). "></a>md5($password,true). </h2><p>SELECT * FROM admin WHERE username = ‘admin’ AND password = md5($password,true).<br>16位原始二进制格式的字符串===16位ascii对应字符的字符串。<br>也就是使得md5($password,true)之后的值为’or’1xxx<br>即：SELECT * FROM admin WHERE username = ‘admin’ and password =’’or’1xxxxx’<br>因为在mysql里面，在用作布尔型判断时，以1开头的字符串会被当做整型数。</p><p>当$password=ffifdyop时，md5($password,true)=‘or’6\xc9]\x99\xe9!r,\xf9\xedb\x1c<br>语句为：<br>SELECT * FROM admin WHERE username = ‘admin’ and password =’’or’6\xc9]\x99\xe9!r,\xf9\xedb\x1c’</p><p>另外：<br>…… password =’’ or x(非零数),也能成功绕过<br>由反斜杠’&#39;和字母x(或X)及随后的1～2个十六进制数字构成的字符序列。<br>例如’\x30’、’\x41’、’\X61’分别表示字符’0’、’A’和’a’。因为字符’0’、’A’和’a’的ASCII码的十六进制值分别为0x30、0x41和0x61。</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content:encoded>
      
      
      <category domain="https://dickfql.github.io/categories/web/">web</category>
      
      <category domain="https://dickfql.github.io/categories/web/php/">php</category>
      
      
      <category domain="https://dickfql.github.io/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/">代码审计</category>
      
      <category domain="https://dickfql.github.io/tags/MD5/">MD5</category>
      
      
      <comments>https://dickfql.github.io/2021/10/23/md5/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Hello World</title>
      <link>https://dickfql.github.io/2021/10/22/hello-world/</link>
      <guid>https://dickfql.github.io/2021/10/22/hello-world/</guid>
      <pubDate>Fri, 22 Oct 2021 13:48:28 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;太难顶了，前期真就与其每天花点时间整点格式，还不如好好找个时间一次性搞完。&lt;br&gt;害~不过还好，博客算是差不多搭建完成了，之后就是添加点文章或者再对网页格式修修改改了。&lt;br&gt;从现在开始，这里就是Fantasy的广场，正式开始我新的旅行。&lt;/p&gt;
&lt;link rel=&quot;st</description>
        
      
      
      
      <content:encoded><![CDATA[<p>太难顶了，前期真就与其每天花点时间整点格式，还不如好好找个时间一次性搞完。<br>害~不过还好，博客算是差不多搭建完成了，之后就是添加点文章或者再对网页格式修修改改了。<br>从现在开始，这里就是Fantasy的广场，正式开始我新的旅行。</p><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content:encoded>
      
      
      
      
      <comments>https://dickfql.github.io/2021/10/22/hello-world/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
